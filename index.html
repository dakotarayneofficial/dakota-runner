<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dakota Land</title>
    <style>
        body { margin: 0; background: #1e3a5f; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Courier New', monospace; overflow: hidden; }
        canvas { border: 4px solid #8B4513; box-shadow: 0 0 30px rgba(0,0,0,0.6); outline: none; }
        #ui { position: absolute; top: 15px; left: 15px; color: white; font-size: 22px; text-shadow: 2px 2px 6px black; pointer-events: none; }
        #startScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; }
        h1 { font-size: 52px; margin: 10px; text-shadow: 3px 3px 8px #ff1493; }
        p { font-size: 24px; margin: 8px; }
        #jumpBtn { position: absolute; bottom: 20px; right: 20px; width: 100px; height: 100px; background: #ff3366; border: none; border-radius: 50%; color: white; font-size: 20px; font-weight: bold; opacity: 0.8; cursor: pointer; pointer-events: all; }
        #jumpBtn:active { transform: scale(0.9); }
    </style>
</head>
<body>
    <canvas id="game" width="800" height="500" tabindex="0"></canvas>
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Distance: <span id="dist">0</span>m</div>
    </div>

    <div id="startScreen">
        <h1>ü§† Dakota Land üé§</h1>
        <p>Brunette Singer Edition</p>
        <p>‚Üê ‚Üí or A D : Run<br>‚Üë or SPACE : Jump<br><br>Click or SPACE to Start</p>
    </div>

    <button id="jumpBtn" title="Jump!">JUMP</button>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const distEl = document.getElementById('dist');
        const startScreen = document.getElementById('startScreen');
        const jumpBtn = document.getElementById('jumpBtn');

        // FIX: Make canvas focusable & auto-focus
        canvas.focus();

        let gameState = { mode: 'start', score: 0, distance: 0 };
        let keys = {};
        let camera = { x: 0 };
        let lastSpawnX = 800;

        const player = {
            x: 120, y: 300, width: 38, height: 62,
            vx: 0, vy: 0, speed: 5.5, accel: 1.2, friction: 0.82,
            jumpPower: -15.5, onGround: false, facingRight: true,
            frame: 0
        };

        let platforms = [{x: 0, y: 420, w: 2500, h: 80}];
        let obstacles = [];
        let coins = [];
        let tumbleweeds = [];

        // FIXED KEY HANDLING: Prevent spacebar scroll + focus on click
        document.addEventListener('keydown', e => { 
            if (e.code === 'Space') {
                e.preventDefault();
            }
            keys[e.code] = true;
            if ((e.code === 'Space' || e.code === 'ArrowUp') && gameState.mode === 'start') startGame();
            if (e.code === 'Space' && gameState.mode === 'gameover') reset();
        });
        document.addEventListener('keyup', e => { 
            keys[e.code] = false; 
        });
        canvas.addEventListener('click', () => {
            canvas.focus(); // Keep focus
            if (gameState.mode === 'start') startGame();
            if (gameState.mode === 'gameover') reset();
        });
        jumpBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (player.onGround && gameState.mode === 'playing') {
                player.vy = player.jumpPower;
                player.onGround = false;
            }
        });

        function startGame() {
            startScreen.style.display = 'none';
            gameState.mode = 'playing';
            reset();
        }

        function reset() {
            player.x = 120; player.y = 300; player.vx = player.vy = 0;
            camera.x = 0; lastSpawnX = 800;
            platforms = [{x: 0, y: 420, w: 2500, h: 80}];
            obstacles = []; coins = []; tumbleweeds = [];
            gameState.score = 0; gameState.distance = 0;
            gameState.mode = 'playing';
            spawnChunk(600);
            canvas.focus();
        }

        function spawnChunk(startX) {
            for (let i = 0; i < 6; i++) {
                const px = startX + i * 180 + Math.random() * 80;
                const py = 280 + Math.random() * 110;
                platforms.push({x: px, y: py, w: 110 + Math.random() * 90, h: 22});
            }
            for (let i = 0; i < 7; i++) {
                const ox = startX + 100 + Math.random() * 900;
                obstacles.push({x: ox, y: 360, w: 28, h: 60});
            }
            for (let i = 0; i < 18; i++) {
                const cx = startX + Math.random() * 1100;
                const cy = 180 + Math.random() * 160;
                coins.push({x: cx, y: cy, r: 10, collected: false});
            }
            for (let i = 0; i < 4; i++) {
                tumbleweeds.push({x: startX + 300 + Math.random() * 700, y: 380, vx: 1.8 + Math.random() * 1.2, size: 18 + Math.random() * 8});
            }
            lastSpawnX = startX + 1100;
        }

        function cleanup() {
            const threshold = camera.x - 300;
            platforms = platforms.filter(p => p.x + p.w > threshold);
            obstacles = obstacles.filter(o => o.x + o.w > threshold);
            coins = coins.filter(c => !c.collected && c.x > threshold);
            tumbleweeds = tumbleweeds.filter(t => t.x > threshold);
        }

        function update() {
            if (gameState.mode !== 'playing') return;

            // Controls + smooth acceleration
            let targetVx = 0;
            if (keys['ArrowRight'] || keys['KeyD']) targetVx = player.speed;
            if (keys['ArrowLeft'] || keys['KeyA']) targetVx = -player.speed * 0.75;
            player.vx += (targetVx - player.vx) * player.accel;
            if (player.onGround) player.vx *= player.friction;

            // FIXED JUMP: More reliable detection
            if ((keys['Space'] || keys['ArrowUp']) && player.onGround) {
                player.vy = player.jumpPower;
                player.onGround = false;
                keys['Space'] = false; // Prevent holding jump
            }

            player.vy += 0.85; // gravity

            // X movement + collision
            player.x += player.vx;
            handleCollisions(true);

            // Y movement + collision
            player.y += player.vy;
            handleCollisions(false);

            // Ground check
            player.onGround = false;
            for (let p of platforms) {
                if (player.x < p.x + p.w && player.x + player.width > p.x &&
                    player.y + player.height > p.y && player.y + player.height < p.y + 18) {
                    player.y = p.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                }
            }

            // Animation
            if (Math.abs(player.vx) > 1 && player.onGround) player.frame = (player.frame + 0.28) % 6;
            else player.frame = 0;
            player.facingRight = player.vx >= 0;

            camera.x = Math.max(0, player.x - 220);

            if (camera.x + 1400 > lastSpawnX) spawnChunk(lastSpawnX);
            cleanup();

            // Collisions
            for (let o of obstacles) {
                if (player.x < o.x + o.w && player.x + player.width > o.x &&
                    player.y < o.y + o.h && player.y + player.height > o.y) die();
            }
            for (let t of tumbleweeds) {
                if (player.x < t.x + t.size && player.x + player.width > t.x &&
                    player.y < t.y + t.size && player.y + player.height > t.y - 10) die();
            }

            // Coins
            for (let c of coins) {
                if (!c.collected) {
                    const dx = player.x + player.width/2 - c.x;
                    const dy = player.y + player.height/2 - c.y;
                    if (dx*dx + dy*dy < 900) {
                        c.collected = true;
                        gameState.score += 150;
                    }
                }
            }

            if (player.y > 620) die();

            gameState.distance = Math.floor(Math.max(0, player.x - 100) / 8);
            gameState.score = Math.floor(gameState.distance * 2);

            scoreEl.textContent = gameState.score;
            distEl.textContent = gameState.distance;
        }

        function handleCollisions(isHorizontal) {
            for (let p of platforms) {
                if (!(player.x < p.x + p.w && player.x + player.width > p.x &&
                      player.y < p.y + p.h && player.y + player.height > p.y)) continue;
                if (isHorizontal) {
                    if (player.vx > 0) player.x = p.x - player.width;
                    else if (player.vx < 0) player.x = p.x + p.w;
                    player.vx = 0;
                } else {
                    if (player.vy > 0) {
                        player.y = p.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                    } else if (player.vy < 0) {
                        player.y = p.y + p.h;
                        player.vy = 0;
                    }
                }
            }
        }

        function die() {
            gameState.mode = 'gameover';
        }

        function drawBackground() {
            const grad = ctx.createLinearGradient(0, 0, 0, 500);
            grad.addColorStop(0, '#7EC0EE'); grad.addColorStop(1, '#E0F0FF');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#5a8c4d';
            for (let i = -1; i < 4; i++) {
                const bx = (i * 350 - camera.x * 0.15) % 1400;
                ctx.beginPath(); ctx.moveTo(bx, 380);
                ctx.quadraticCurveTo(bx+120, 260, bx+280, 380); ctx.fill();
            }
        }

        function drawCowgirl() {
            ctx.save();
            const px = player.x - camera.x;
            const py = player.y;
            ctx.translate(px + 19, py + 31);
            if (!player.facingRight) ctx.scale(-1, 1);

            const runCycle = player.onGround ? Math.sin(player.frame * Math.PI * 1.6) * 12 : 0;

            // Hat & Hair
            ctx.fillStyle = '#3d2b1f'; ctx.fillRect(-19, -48, 38, 14);
            ctx.fillStyle = '#5c4033'; ctx.fillRect(-13, -55, 26, 18);
            ctx.fillStyle = '#4a2f25'; ctx.fillRect(-18, -38, 26, 42);
            ctx.fillRect(8, -32 + runCycle*0.3, 11, 28); // ponytail bounce

            // Face + body (hot curves)
            ctx.fillStyle = '#f8d0b8'; ctx.fillRect(-12, -28, 24, 26);
            ctx.fillStyle = '#ff99cc'; ctx.fillRect(-16, -8, 32, 18); // bust
            ctx.fillStyle = '#ff3366'; ctx.fillRect(-16, -6, 32, 22); // tight shirt

            // Short denim shorts
            ctx.fillStyle = '#2b5a8c'; ctx.fillRect(-15, 14, 30, 18);

            // Arms + mic
            const armSwing = player.onGround ? Math.sin(player.frame * Math.PI * 2) * 7 : -8;
            ctx.fillStyle = '#f8d0b8';
            ctx.fillRect(-19, 2, 8, 22);
            ctx.fillRect(11, 2 + armSwing*0.6, 8, 20);
            ctx.fillStyle = '#aaaaaa'; ctx.fillRect(18, 12 + armSwing*0.6, 6, 18);
            ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(21, 28 + armSwing*0.6, 3.5, 0, Math.PI*2); ctx.fill();

            // Legs + boots (run animation)
            const legOffset = runCycle * 0.5;
            ctx.fillStyle = '#2b5a8c';
            ctx.fillRect(-14 + legOffset*0.2, 30, 11, 26);
            ctx.fillRect(3 - legOffset*0.2, 30, 11, 26);
            ctx.fillStyle = '#222';
            ctx.fillRect(-17 + legOffset*0.2, 52, 14, 10);
            ctx.fillRect(1 - legOffset*0.2, 52, 14, 10);

            ctx.restore();
        }

        function draw() {
            drawBackground();

            ctx.fillStyle = '#c17f4e';
            for (let p of platforms) ctx.fillRect(p.x - camera.x, p.y, p.w, p.h);

            ctx.fillStyle = '#1e8c2f';
            for (let o of obstacles) {
                ctx.fillRect(o.x - camera.x, o.y, o.w, o.h);
            }

            ctx.fillStyle = '#ffcc00';
            for (let c of coins) {
                if (!c.collected) {
                    const cx = c.x - camera.x;
                    ctx.beginPath(); ctx.arc(cx, c.y, c.r, 0, Math.PI*2); ctx.fill();
                }
            }

            ctx.strokeStyle = '#8B5A2B'; ctx.lineWidth = 3;
            for (let t of tumbleweeds) {
                const tx = t.x - camera.x;
                ctx.beginPath(); ctx.arc(tx, t.y + 8, t.size, 0, Math.PI*2); ctx.stroke();
            }

            drawCowgirl();

            // Hide jump btn during gameover/start
            jumpBtn.style.display = gameState.mode === 'playing' ? 'block' : 'none';

            if (gameState.mode === 'gameover') {
                ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ff3366'; ctx.font = 'bold 58px Arial'; ctx.textAlign = 'center';
                ctx.fillText('YA BIT THE DUST!', canvas.width/2, 200);
                ctx.fillStyle = 'white'; ctx.font = '28px Arial';
                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width/2, 270);
                ctx.fillText('Click or SPACE to Try Again', canvas.width/2, 340);
            }
        }

        function loop() {
            update();
            if (gameState.mode === 'playing') {
                for (let t of tumbleweeds) t.x += t.vx;
            }
            draw();
            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>
</html>
